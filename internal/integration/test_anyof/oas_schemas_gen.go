// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/jx"
	"github.com/google/uuid"
)

// Ref: #/components/schemas/AnyOfIntegerNumberString
// AnyOfIntegerNumberString represents sum type.
type AnyOfIntegerNumberString struct {
	Type    AnyOfIntegerNumberStringType // switch on this field
	Int     int
	Float64 float64
	String  string
}

// AnyOfIntegerNumberStringType is oneOf type of AnyOfIntegerNumberString.
type AnyOfIntegerNumberStringType string

// Possible values for AnyOfIntegerNumberStringType.
const (
	IntAnyOfIntegerNumberString     AnyOfIntegerNumberStringType = "int"
	Float64AnyOfIntegerNumberString AnyOfIntegerNumberStringType = "float64"
	StringAnyOfIntegerNumberString  AnyOfIntegerNumberStringType = "string"
)

// IsInt reports whether AnyOfIntegerNumberString is int.
func (s AnyOfIntegerNumberString) IsInt() bool { return s.Type == IntAnyOfIntegerNumberString }

// IsFloat64 reports whether AnyOfIntegerNumberString is float64.
func (s AnyOfIntegerNumberString) IsFloat64() bool { return s.Type == Float64AnyOfIntegerNumberString }

// IsString reports whether AnyOfIntegerNumberString is string.
func (s AnyOfIntegerNumberString) IsString() bool { return s.Type == StringAnyOfIntegerNumberString }

// SetInt sets AnyOfIntegerNumberString to int.
func (s *AnyOfIntegerNumberString) SetInt(v int) {
	s.Type = IntAnyOfIntegerNumberString
	s.Int = v
}

// GetInt returns int and true boolean if AnyOfIntegerNumberString is int.
func (s AnyOfIntegerNumberString) GetInt() (v int, ok bool) {
	if !s.IsInt() {
		return v, false
	}
	return s.Int, true
}

// NewIntAnyOfIntegerNumberString returns new AnyOfIntegerNumberString from int.
func NewIntAnyOfIntegerNumberString(v int) AnyOfIntegerNumberString {
	var s AnyOfIntegerNumberString
	s.SetInt(v)
	return s
}

// encodeFields encodes the fields of sum type AnyOfIntegerNumberString.
func (s AnyOfIntegerNumberString) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case IntAnyOfIntegerNumberString:
		s.Int.encodeFields(e)
		return nil
	case Float64AnyOfIntegerNumberString:
		s.Float64.encodeFields(e)
		return nil
	case StringAnyOfIntegerNumberString:
		s.String.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

// SetFloat64 sets AnyOfIntegerNumberString to float64.
func (s *AnyOfIntegerNumberString) SetFloat64(v float64) {
	s.Type = Float64AnyOfIntegerNumberString
	s.Float64 = v
}

// GetFloat64 returns float64 and true boolean if AnyOfIntegerNumberString is float64.
func (s AnyOfIntegerNumberString) GetFloat64() (v float64, ok bool) {
	if !s.IsFloat64() {
		return v, false
	}
	return s.Float64, true
}

// NewFloat64AnyOfIntegerNumberString returns new AnyOfIntegerNumberString from float64.
func NewFloat64AnyOfIntegerNumberString(v float64) AnyOfIntegerNumberString {
	var s AnyOfIntegerNumberString
	s.SetFloat64(v)
	return s
}

// encodeFields encodes the fields of sum type AnyOfIntegerNumberString.
func (s AnyOfIntegerNumberString) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case IntAnyOfIntegerNumberString:
		s.Int.encodeFields(e)
		return nil
	case Float64AnyOfIntegerNumberString:
		s.Float64.encodeFields(e)
		return nil
	case StringAnyOfIntegerNumberString:
		s.String.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

// SetString sets AnyOfIntegerNumberString to string.
func (s *AnyOfIntegerNumberString) SetString(v string) {
	s.Type = StringAnyOfIntegerNumberString
	s.String = v
}

// GetString returns string and true boolean if AnyOfIntegerNumberString is string.
func (s AnyOfIntegerNumberString) GetString() (v string, ok bool) {
	if !s.IsString() {
		return v, false
	}
	return s.String, true
}

// NewStringAnyOfIntegerNumberString returns new AnyOfIntegerNumberString from string.
func NewStringAnyOfIntegerNumberString(v string) AnyOfIntegerNumberString {
	var s AnyOfIntegerNumberString
	s.SetString(v)
	return s
}

// encodeFields encodes the fields of sum type AnyOfIntegerNumberString.
func (s AnyOfIntegerNumberString) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case IntAnyOfIntegerNumberString:
		s.Int.encodeFields(e)
		return nil
	case Float64AnyOfIntegerNumberString:
		s.Float64.encodeFields(e)
		return nil
	case StringAnyOfIntegerNumberString:
		s.String.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

// Ref: #/components/schemas/IntegerNumber
type IntegerNumber struct {
	Plain AnyOfIntegerNumberString `json:"plain"`
}

// GetPlain returns the value of Plain.
func (s *IntegerNumber) GetPlain() AnyOfIntegerNumberString {
	return s.Plain
}

// SetPlain sets the value of Plain.
func (s *IntegerNumber) SetPlain(val AnyOfIntegerNumberString) {
	s.Plain = val
}

// Ref: #/components/schemas/JaegerAnyOf
type JaegerAnyOf struct {
	Medium    string               `json:"medium"`
	SizeLimit JaegerAnyOfSizeLimit `json:"sizeLimit"`
}

// GetMedium returns the value of Medium.
func (s *JaegerAnyOf) GetMedium() string {
	return s.Medium
}

// GetSizeLimit returns the value of SizeLimit.
func (s *JaegerAnyOf) GetSizeLimit() JaegerAnyOfSizeLimit {
	return s.SizeLimit
}

// SetMedium sets the value of Medium.
func (s *JaegerAnyOf) SetMedium(val string) {
	s.Medium = val
}

// SetSizeLimit sets the value of SizeLimit.
func (s *JaegerAnyOf) SetSizeLimit(val JaegerAnyOfSizeLimit) {
	s.SizeLimit = val
}

// JaegerAnyOfSizeLimit represents sum type.
type JaegerAnyOfSizeLimit struct {
	Type   JaegerAnyOfSizeLimitType // switch on this field
	Int    int
	String string
}

// JaegerAnyOfSizeLimitType is oneOf type of JaegerAnyOfSizeLimit.
type JaegerAnyOfSizeLimitType string

// Possible values for JaegerAnyOfSizeLimitType.
const (
	IntJaegerAnyOfSizeLimit    JaegerAnyOfSizeLimitType = "int"
	StringJaegerAnyOfSizeLimit JaegerAnyOfSizeLimitType = "string"
)

// IsInt reports whether JaegerAnyOfSizeLimit is int.
func (s JaegerAnyOfSizeLimit) IsInt() bool { return s.Type == IntJaegerAnyOfSizeLimit }

// IsString reports whether JaegerAnyOfSizeLimit is string.
func (s JaegerAnyOfSizeLimit) IsString() bool { return s.Type == StringJaegerAnyOfSizeLimit }

// SetInt sets JaegerAnyOfSizeLimit to int.
func (s *JaegerAnyOfSizeLimit) SetInt(v int) {
	s.Type = IntJaegerAnyOfSizeLimit
	s.Int = v
}

// GetInt returns int and true boolean if JaegerAnyOfSizeLimit is int.
func (s JaegerAnyOfSizeLimit) GetInt() (v int, ok bool) {
	if !s.IsInt() {
		return v, false
	}
	return s.Int, true
}

// NewIntJaegerAnyOfSizeLimit returns new JaegerAnyOfSizeLimit from int.
func NewIntJaegerAnyOfSizeLimit(v int) JaegerAnyOfSizeLimit {
	var s JaegerAnyOfSizeLimit
	s.SetInt(v)
	return s
}

// encodeFields encodes the fields of sum type JaegerAnyOfSizeLimit.
func (s JaegerAnyOfSizeLimit) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case IntJaegerAnyOfSizeLimit:
		s.Int.encodeFields(e)
		return nil
	case StringJaegerAnyOfSizeLimit:
		s.String.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

// SetString sets JaegerAnyOfSizeLimit to string.
func (s *JaegerAnyOfSizeLimit) SetString(v string) {
	s.Type = StringJaegerAnyOfSizeLimit
	s.String = v
}

// GetString returns string and true boolean if JaegerAnyOfSizeLimit is string.
func (s JaegerAnyOfSizeLimit) GetString() (v string, ok bool) {
	if !s.IsString() {
		return v, false
	}
	return s.String, true
}

// NewStringJaegerAnyOfSizeLimit returns new JaegerAnyOfSizeLimit from string.
func NewStringJaegerAnyOfSizeLimit(v string) JaegerAnyOfSizeLimit {
	var s JaegerAnyOfSizeLimit
	s.SetString(v)
	return s
}

// encodeFields encodes the fields of sum type JaegerAnyOfSizeLimit.
func (s JaegerAnyOfSizeLimit) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case IntJaegerAnyOfSizeLimit:
		s.Int.encodeFields(e)
		return nil
	case StringJaegerAnyOfSizeLimit:
		s.String.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

// Ref: #/components/schemas/OneUUID
type OneUUID struct {
	Owner          string                `json:"owner"`
	Version        int32                 `json:"version"`
	SubscriptionID OneUUIDSubscriptionID `json:"subscription_id"`
}

// GetOwner returns the value of Owner.
func (s *OneUUID) GetOwner() string {
	return s.Owner
}

// GetVersion returns the value of Version.
func (s *OneUUID) GetVersion() int32 {
	return s.Version
}

// GetSubscriptionID returns the value of SubscriptionID.
func (s *OneUUID) GetSubscriptionID() OneUUIDSubscriptionID {
	return s.SubscriptionID
}

// SetOwner sets the value of Owner.
func (s *OneUUID) SetOwner(val string) {
	s.Owner = val
}

// SetVersion sets the value of Version.
func (s *OneUUID) SetVersion(val int32) {
	s.Version = val
}

// SetSubscriptionID sets the value of SubscriptionID.
func (s *OneUUID) SetSubscriptionID(val OneUUIDSubscriptionID) {
	s.SubscriptionID = val
}

// OneUUIDSubscriptionID represents sum type.
type OneUUIDSubscriptionID struct {
	Type             OneUUIDSubscriptionIDType // switch on this field
	SubscriptionUUID SubscriptionUUID
}

// OneUUIDSubscriptionIDType is oneOf type of OneUUIDSubscriptionID.
type OneUUIDSubscriptionIDType string

// Possible values for OneUUIDSubscriptionIDType.
const (
	SubscriptionUUIDOneUUIDSubscriptionID OneUUIDSubscriptionIDType = "SubscriptionUUID"
)

// IsSubscriptionUUID reports whether OneUUIDSubscriptionID is SubscriptionUUID.
func (s OneUUIDSubscriptionID) IsSubscriptionUUID() bool {
	return s.Type == SubscriptionUUIDOneUUIDSubscriptionID
}

// SetSubscriptionUUID sets OneUUIDSubscriptionID to SubscriptionUUID.
func (s *OneUUIDSubscriptionID) SetSubscriptionUUID(v SubscriptionUUID) {
	s.Type = SubscriptionUUIDOneUUIDSubscriptionID
	s.SubscriptionUUID = v
}

// GetSubscriptionUUID returns SubscriptionUUID and true boolean if OneUUIDSubscriptionID is SubscriptionUUID.
func (s OneUUIDSubscriptionID) GetSubscriptionUUID() (v SubscriptionUUID, ok bool) {
	if !s.IsSubscriptionUUID() {
		return v, false
	}
	return s.SubscriptionUUID, true
}

// NewSubscriptionUUIDOneUUIDSubscriptionID returns new OneUUIDSubscriptionID from SubscriptionUUID.
func NewSubscriptionUUIDOneUUIDSubscriptionID(v SubscriptionUUID) OneUUIDSubscriptionID {
	var s OneUUIDSubscriptionID
	s.SetSubscriptionUUID(v)
	return s
}

// encodeFields encodes the fields of sum type OneUUIDSubscriptionID.
func (s OneUUIDSubscriptionID) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case SubscriptionUUIDOneUUIDSubscriptionID:
		s.SubscriptionUUID.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

// Ref: #/components/schemas/SubscriptionUUID
// SubscriptionUUID represents sum type.
type SubscriptionUUID struct {
	Type   SubscriptionUUIDType // switch on this field
	UUIDv4 UUIDv4
}

// SubscriptionUUIDType is oneOf type of SubscriptionUUID.
type SubscriptionUUIDType string

// Possible values for SubscriptionUUIDType.
const (
	UUIDv4SubscriptionUUID SubscriptionUUIDType = "UUIDv4"
)

// IsUUIDv4 reports whether SubscriptionUUID is UUIDv4.
func (s SubscriptionUUID) IsUUIDv4() bool { return s.Type == UUIDv4SubscriptionUUID }

// SetUUIDv4 sets SubscriptionUUID to UUIDv4.
func (s *SubscriptionUUID) SetUUIDv4(v UUIDv4) {
	s.Type = UUIDv4SubscriptionUUID
	s.UUIDv4 = v
}

// GetUUIDv4 returns UUIDv4 and true boolean if SubscriptionUUID is UUIDv4.
func (s SubscriptionUUID) GetUUIDv4() (v UUIDv4, ok bool) {
	if !s.IsUUIDv4() {
		return v, false
	}
	return s.UUIDv4, true
}

// NewUUIDv4SubscriptionUUID returns new SubscriptionUUID from UUIDv4.
func NewUUIDv4SubscriptionUUID(v UUIDv4) SubscriptionUUID {
	var s SubscriptionUUID
	s.SetUUIDv4(v)
	return s
}

// encodeFields encodes the fields of sum type SubscriptionUUID.
func (s SubscriptionUUID) encodeFields(e *jx.Encoder) error {
	switch s.Type {
	case UUIDv4SubscriptionUUID:
		s.UUIDv4.encodeFields(e)
		return nil
	default:
		// We shouldn't ever reach this branch since all cases are enumerated above,
		// but we include it in case something unexpected happens
		return fmt.Errorf("encodeFields: unknown sum type %s", s.Type)
	}
}

type UUIDv4 uuid.UUID
